<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>






<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta property="og:type" content="website">
<meta property="og:title" content="帅到没朋友">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="帅到没朋友">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="帅到没朋友">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>帅到没朋友</title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  















  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">帅到没朋友</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/09/06/数据结构与算法/经典算法——动态规划入门实例/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="forever_zs">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/head.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="帅到没朋友">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/06/数据结构与算法/经典算法——动态规划入门实例/" itemprop="url">经典算法——动态规划入门实例</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-06T12:10:33+08:00">
                2017-09-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="经典算法——动态规划入门实例"><a href="#经典算法——动态规划入门实例" class="headerlink" title="经典算法——动态规划入门实例"></a>经典算法——动态规划入门实例</h2><p>[TOC]</p>
<h4 id="神马是动态规划"><a href="#神马是动态规划" class="headerlink" title="神马是动态规划"></a>神马是动态规划</h4><ul>
<li><p>专业定义：</p>
<p>动态规划的本质，是对问题<strong>状态的定义</strong>和<strong>状态转移方程的定义</strong>。通过<strong>拆分问题，</strong>定义问题状态和状态之间的关系，使得问题能够以递推（或者说分治）的方式去解决。</p>
<p>看完之后或许你一个字也没记住，这都是什么鬼？</p>
<p><img src="http://img.blog.csdn.net/20170906112358977?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemhhb3NodWFpd2pt/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
</li>
<li><p>关键点</p>
<p>ok，让我们摒弃这些专业的条条框框，直奔主题。其实动态规划的核心就是<strong>拆解子问题</strong>——把一个大的问题拆解成逐步逐步的小问题，<strong>而这些小问题都可以直接由之前更小的问题得到</strong>。那么怎么拆解这些小问题呢？</p>
<p>靠的就是<strong>状态的定义</strong>和<strong>状态转移方程的定义</strong>。</p>
<p>当然，这样还是很抽象的。不如举个栗子：</p>
<p><img src="http://img.blog.csdn.net/20170906113800717?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemhhb3NodWFpd2pt/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
</li>
</ul>
<h4 id="求解最长公共字串"><a href="#求解最长公共字串" class="headerlink" title="求解最长公共字串"></a>求解最长公共字串</h4><ul>
<li><p>神马是最长公共字串？</p>
<p>假定现在有两个字符串，最长公共字串就是它们之间<strong>公有的连续的</strong>最长字串，就像下图这样</p>
<p><img src="http://img.blog.csdn.net/20170906114919837?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemhhb3NodWFpd2pt/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>橙色部分就是最长的公有字串，记住这里一定要连续。那么问题来了？怎么求出任意两个字符串的最长公有字串呢？看似很简单，不过细思又感觉有点点复杂的感觉。</p>
</li>
<li><p>暴力求解</p>
<p>简单粗暴的方法——先求出str1的所有子序列，然后在求出str2的所有子序列，然后再一个个比较，找到相同且最大的那个不就好了。ok，我们先来看看要多少次：</p>
<p>str1的可能情况：</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">n+(n<span class="number">-1</span>)+(n<span class="number">-1</span>)+.......+<span class="number">2</span>+<span class="number">1</span> = ((n+<span class="number">1</span>)*n)/<span class="number">2</span></div></pre></td></tr></table></figure>
<p>同理str2也是一样：</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">m+(m<span class="number">-1</span>)+(m<span class="number">-1</span>)+.......+<span class="number">2</span>+<span class="number">1</span> = ((m+<span class="number">1</span>)*m)/<span class="number">2</span></div></pre></td></tr></table></figure>
<p>然后在通过两个for循环一个一个比较就搞定了嘛；</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(((n+<span class="number">1</span>)*n)/<span class="number">2</span>):</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(((m + <span class="number">1</span>) * m) / <span class="number">2</span>):</div><div class="line">        dosomthing()</div></pre></td></tr></table></figure>
<p>ok，这样不就搞定了，不过有点细思极恐，这也太暴力了，万一字符串很大，这得算多久呀！心疼计算机3s。正所谓暴力膜法不可取，所以这时候我们的动态规划就登场啦。</p>
</li>
<li><p>最开始我们说过，用动态规划算法时最重要的就是要拆解子问题，那么我们如何将这个问题拆解为更小的子问题呢？根据动态规划的思想，我们首先要分析出如何根据已有的结果算出我们需要的结果，举栗来说：</p>
<p><img src="http://img.blog.csdn.net/20170906140202599?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemhhb3NodWFpd2pt/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>​    假如我们已经求好了截至到str1[i-1]与str2[j-1]处两个字符串的最大公有子串，是否可以帮助我们求出截止到str1[i]与str[j]处两个字符串的最大公有子串呢？思考一下：</p>
<p>​    为了方便，我们将截止到（<strong>这里的截止到要包含str1[i]与str2[j]</strong>）str[i]与str[j]处的最大字符串长度记作<code>lcs(i,j)</code>，假如：str1[i] == str2[j]，那么我们直接在lcs(i-1，j-1)后面加1不就是lcs（i，j）了嘛，如果str1[i] !=str2[j]，最大公有子串到这里就结束了，所以经过这个点没有最大公有子串，直接记作0就好了。</p>
<p>用数学公式就是：</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">f(m,n)=<span class="number">0</span>        str1[m] != str2[n] ;</div><div class="line">f(m,n)=f(m<span class="number">-1</span>,n<span class="number">-1</span>) + <span class="number">1</span>      str[m]==str2[n];</div></pre></td></tr></table></figure>
<p>转化为代码就是：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> str1[i]==str2[j]:</div><div class="line">    lcs[i][j] = lcs[i<span class="number">-1</span>][j<span class="number">-1</span>] + <span class="number">1</span></div><div class="line"><span class="keyword">else</span>:</div><div class="line">    lcs[i][j] = <span class="number">0</span></div></pre></td></tr></table></figure>
<p>用一张图片描述整体流程就是：</p>
<p><img src="http://img.blog.csdn.net/20170906142444815?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemhhb3NodWFpd2pt/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>ok，既然弄清楚了计算的流程，就可以写出代码，完整代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">lcs</span><span class="params">(mes1, mes2)</span>:</span></div><div class="line">    <span class="keyword">if</span> len(mes1) &gt; len(mes2):</div><div class="line">        mes1, mes2 = mes2, mes1</div><div class="line">    data = [[<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(len(mes2) + <span class="number">1</span>)] <span class="keyword">for</span> i <span class="keyword">in</span> range(len(mes1) + <span class="number">1</span>)]</div><div class="line">    <span class="comment">#加上前缀，方便我们从1开始遍历</span></div><div class="line">    mes1 = <span class="string">"$"</span> + mes1</div><div class="line">    mes2 = <span class="string">"$"</span> + mes2</div><div class="line">    max_lenth = <span class="number">0</span></div><div class="line">    end = <span class="number">0</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(mes1)):</div><div class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, len(mes2)):</div><div class="line">            <span class="keyword">if</span> mes1[i] == mes2[j]:</div><div class="line">                data[i][j] = data[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span></div><div class="line">                <span class="keyword">if</span> data[i][j] &gt; max_lenth:</div><div class="line">                    max_lenth = data[i][j]</div><div class="line">                    end = i</div><div class="line"></div><div class="line">    <span class="keyword">if</span> max != <span class="number">0</span>:</div><div class="line">        result = mes1[end - max_lenth + <span class="number">1</span>:end + <span class="number">1</span>]</div><div class="line">        print(result)</div></pre></td></tr></table></figure>
<p>if <strong>name</strong> == ‘<strong>main</strong>‘:</p>
<pre><code>while True:
    try:
        mes1 = input()
        mes2 = input()
        lcs(mes1, mes2)
    except:
        break
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">  这里申请的二维数组比两个字符串都要大1，原因为我们呢将i，j为0的边都赋值为了0（当然，这里为了方便直接把数组都初始化了为0），有点像为我们的动态规划棋盘撒了半圈水雷一样。参考上面的流程图。这是一道经典的动态规划题目，在华为的笔试题里面曾经出现过，上面代码就是之前根据题目写的，已经通过了测试。原题如下：</div><div class="line"></div><div class="line">  ![这里写图片描述](http://img.blog.csdn.net/20170906143552120?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemhhb3NodWFpd2pt/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">#### 求解最大公有子序列</div><div class="line"></div><div class="line">* 神马是最大公有子序列</div><div class="line"></div><div class="line">  乍一看，和最大公共子串就两字之差，其实这两个差的还是挺远的。还是上面那两个字符串：</div><div class="line"></div><div class="line">  ![这里写图片描述](http://img.blog.csdn.net/20170906144040321?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemhhb3NodWFpd2pt/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)</div><div class="line"></div><div class="line">  橙色部分就是他们的最大公有子序列。和子串最大的区别就是这里的子串可以不用连续了，所以叫最大子序列了。这种算法有什么用呢？</div><div class="line"></div><div class="line">  比如：有次毛概老师让你写一篇5000字的论文，可是要交的前一天晚上你才想起来怎么办？当然是网上随便找一篇，但是你又怕老师发现是抄袭的，所以就会在文章开头改点东西，文章中间改点，文章结尾改点，当你以为万事大吉的时候，如果老师刚好学过这个算法，那么可以通过对比最大子序列找到文章的相似度了，然后就。。。。</div><div class="line"></div><div class="line">* 暴力求解</div><div class="line"></div><div class="line">  。。。。。。。。。。。。这个子集比之前的高多了，有兴趣朋友可以计算试试。。。。。。。</div><div class="line"></div><div class="line">* 其实仔细想想，这个和最大子串其实是一样一样的，就是递推公式有一丢丢不同，希望大家稍微思考下，应该很快就写出来了。完整代码如下，建议对比之前代码就会发现差别了：</div><div class="line"></div><div class="line">  ```python</div><div class="line">  def lcs(mes1, mes2):</div><div class="line">      if len(mes1) &gt; len(mes2):</div><div class="line">          mes1, mes2 = mes2, mes1</div><div class="line">      data = [[0 for i in range(len(mes2) + 1)] for i in range(len(mes1) + 1)]</div><div class="line">      mes1 = &quot;$&quot; + mes1</div><div class="line">      mes2 = &quot;$&quot; + mes2</div><div class="line">      max_lenth = 0</div><div class="line">      end = 0</div><div class="line">      for i in range(1, len(mes1)):</div><div class="line">          for j in range(1, len(mes2)):</div><div class="line">              if mes1[i] == mes2[j]:</div><div class="line">                  data[i][j] = data[i - 1][j - 1] + 1</div><div class="line">              else:</div><div class="line">                  data[i][j] = max(data[i - 1][j], data[i][j - 1])</div><div class="line">      i = len(mes1) - 1</div><div class="line">      j = len(mes2) - 1</div><div class="line">      str = &quot;&quot;</div><div class="line">      while i != 0 and j != 0:</div><div class="line">          if mes1[i] == mes2[j]:</div><div class="line">              str += mes1[i]</div><div class="line">              i -= 1</div><div class="line">              j -= 1</div><div class="line">          else:</div><div class="line">              if data[i][j - 1] &gt; data[i - 1][j]:</div><div class="line">                  j -= 1</div><div class="line">              else:</div><div class="line">                  i -= 1</div><div class="line">      print(str[::-1])</div><div class="line"></div><div class="line"></div><div class="line">  if __name__ == &apos;__main__&apos;:</div><div class="line">      lcs(&quot;abcdacgw&quot;, &quot;acdacvgwc&quot;)</div></pre></td></tr></table></figure>
<p>其实就是拷贝的前面代码，改了几行代码和输出而已。</p>
</li>
</ul>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul>
<li>算法是一门很理论通过也很实践的学问，建议先搞清流程，再写代码加深理解。本人算法菜鸟，如果错误，欢迎一起探讨。共同学习进步</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/22/数据结构与算法/六大排序算法图解以及python实现/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="forever_zs">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/head.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="帅到没朋友">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/22/数据结构与算法/六大排序算法图解以及python实现/" itemprop="url">六大排序算法图解以及python实现</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-22T20:10:33+08:00">
                2017-08-22
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/数据结构与算法/" itemprop="url" rel="index">
                    <span itemprop="name">数据结构与算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="六大排序算法图解以及python实现"><a href="#六大排序算法图解以及python实现" class="headerlink" title="六大排序算法图解以及python实现"></a>六大排序算法图解以及python实现</h2><p>[TOC]</p>
<p>冒泡排序——名字好听的排序</p>
<ul>
<li><p>大学最先接触的一种排序算法，听名字就很萌的感觉，也是比较简单的一种，算法图示如下：</p>
<p><img src="http://img.blog.csdn.net/20170823173231841?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemhhb3NodWFpd2pt/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>上图为第一次进行比较的图示：</p>
<ul>
<li><p>从第一个开始每次都比较相邻的两个数，如果发现顺序不对，就把两个数交换一下，直到最后一个。这个时候，最大的数自然而然就跑到最后一位上面去了。</p>
</li>
<li><p>第二次的时候，也从第一个开始，不过只需要循环到n-2处就行了（因为n-1处经过第一次洗礼已经时最大了嘛。）</p>
<p>。。。。。。依此类推，循环n次，整个数组就会变成有序的了。</p>
</li>
</ul>
</li>
<li><p>实现代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubble</span><span class="params">(nums)</span>:</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</div><div class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(len(nums)-i<span class="number">-1</span>):</div><div class="line">            <span class="keyword">if</span> nums[j+<span class="number">1</span>] &gt; nums[j]:</div><div class="line">                nums[j+<span class="number">1</span>], nums[j] = nums[j], nums[j+<span class="number">1</span>]</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="选择排序——简单粗暴的排序"><a href="#选择排序——简单粗暴的排序" class="headerlink" title="选择排序——简单粗暴的排序"></a>选择排序——简单粗暴的排序</h4><ul>
<li><p>选择排序大概是所有排序中最好理解，最简单粗暴的排序了。算法图示如下：</p>
<p><img src="http://img.blog.csdn.net/20170823174432168?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemhhb3NodWFpd2pt/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>如图所示：</p>
<ol>
<li><p>在第一次遍历中，从最开始到最后。找到最大的数，并于最后一个交换。</p>
</li>
<li><p>在第二次中，从最开始到倒数第二个。找到最大的数，并于倒数第二个交换。</p>
<p>。。。。以此类推，循环n次。完成没有任何技术含量，所以效率几乎也是所有排序中最低的，强烈不推荐。</p>
</li>
</ol>
</li>
<li><p>算法实现</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">select_sort</span><span class="params">(nums)</span>:</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</div><div class="line">        flag = i</div><div class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i, len(nums)):</div><div class="line">            <span class="keyword">if</span> nums[j] &gt; nums[flag]:</div><div class="line">                flag = j</div><div class="line">        nums[i], nums[flag] = nums[flag], nums[i]</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="插入排序——优雅不要污"><a href="#插入排序——优雅不要污" class="headerlink" title="插入排序——优雅不要污"></a>插入排序——优雅不要污</h4><ul>
<li><p>也是很简单的一种算法，同时也是后面的希尔排序的基础。如下图流程所示：</p>
<p><img src="http://img.blog.csdn.net/20170823175502024?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemhhb3NodWFpd2pt/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>基本思想：</p>
<ol>
<li>首先明确，第一个数肯定是有序的呀（一个数难道还能无序吗？），然后从第二个开始，从后往前扫描，把这个数插入到合适的位置，比第二个数大的一次往后面移动。</li>
<li>第二个数移动正确的位置之后，前两个数就是有序的，依次把后面的数按照刚才的方法插入到合适的位置，整个数组就变成有序的了。</li>
</ol>
</li>
<li><p>代码实现：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">insert_sort</span><span class="params">(nums)</span>:</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(nums)):</div><div class="line">        temp = nums[i]</div><div class="line">        last = <span class="number">0</span></div><div class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</div><div class="line">            <span class="keyword">if</span> nums[j] &gt; temp:</div><div class="line">                nums[j + <span class="number">1</span>] = nums[j]</div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                last = j + <span class="number">1</span></div><div class="line">                <span class="keyword">break</span></div><div class="line">        nums[last] = temp</div></pre></td></tr></table></figure>
<p>​</p>
</li>
</ul>
<h4 id="希尔排序——插入排序的升级版"><a href="#希尔排序——插入排序的升级版" class="headerlink" title="希尔排序——插入排序的升级版"></a>希尔排序——插入排序的升级版</h4><ul>
<li><p>希尔排序是插入排序的优化版，虽然表面上看起来并没有什么优化，相对于插入排序引入了步长的概念</p>
<p><img src="http://img.blog.csdn.net/20170824092331278?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemhhb3NodWFpd2pt/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>如图所示：上图就表示step为4的场景。这时候整数数组的数据按照步长分为如上四组，对每一组都分别进行插入排序。</p>
<ul>
<li><p>当完成第一轮插入排序之后，step的步长减半，进行第二轮插入排序。</p>
<p>。。。。以此类推，直到步长step=1的那一轮排序完成，整个数组就可以变为有序了。</p>
</li>
</ul>
<p>不过问题来了：这最后一轮不和插入排序一毛一样么？这能提高效率：</p>
<p><img src="http://img.blog.csdn.net/20170824093035560?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemhhb3NodWFpd2pt/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>回答是：当然可以！其实每一次我们排序的时候整体都在逐渐趋于有序，都在不断的降低最后一步时的时间复杂度。在step合适的情况下，时间复杂度可以达到O（n^1.3），虽然我也不知道怎么算出来的，估计得问问数学家了。</p>
</li>
</ul>
<h4 id="快速排序——名字最牛逼的排序"><a href="#快速排序——名字最牛逼的排序" class="headerlink" title="快速排序——名字最牛逼的排序"></a>快速排序——名字最牛逼的排序</h4><ul>
<li><p>大名鼎鼎的快排，听名字就无意中透漏着我是最屌的感觉。</p>
<p><img src="http://img.blog.csdn.net/20170824093744604?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemhhb3NodWFpd2pt/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
</li>
<li><p>快排的基本思想就是先找到一个数作为patition，将数组中比patition小的数放在其左边，比patition大的数放在其右边，然后对其每一边再分别进行相同的操作（递归实现）。</p>
<p><img src="http://img.blog.csdn.net/20170824094526375?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemhhb3NodWFpd2pt/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>上图是具体实现的思路：</p>
<ol>
<li>我们一般已第一个数为partition，然后由两个标兵分别指向开始和结尾。</li>
<li>由最右边的橙色箭头开始往前扫描，直到扫描到比partition小的数字停下来，然后再由蓝色箭头向后扫描，直到遇见比partition大的数字停下来。然后交换停下来的两个数字。</li>
<li>就这样按照顺序，一直扫描。知道橙蓝两个箭头相遇，将相遇时的数字与partition交换就行了。</li>
</ol>
</li>
<li><p>编程实现：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">quick_sort</span><span class="params">(nums, start, end)</span>:</span></div><div class="line">    <span class="keyword">if</span> end &lt; start:</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span></div><div class="line">    flag = nums[start]</div><div class="line">    left = start</div><div class="line">    right = end</div><div class="line">    <span class="keyword">while</span> start &lt; end:</div><div class="line">        <span class="keyword">while</span> nums[end] &gt; flag <span class="keyword">and</span> end &gt; start:</div><div class="line">            end -= <span class="number">1</span></div><div class="line">        <span class="keyword">while</span> nums[start] &lt;= flag <span class="keyword">and</span> end &gt; start:</div><div class="line">            start += <span class="number">1</span></div><div class="line">        nums[end], nums[start] = nums[start], nums[end]</div><div class="line">    nums[left], nums[end] = nums[end], nums[left]</div><div class="line">    quick_sort(nums, left, end - <span class="number">1</span>)</div><div class="line">    quick_sort(nums, end + <span class="number">1</span>, right)  </div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></div><div class="line">    nums = [<span class="number">6</span>, <span class="number">3</span>, <span class="number">10</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">23</span>, <span class="number">4</span>, <span class="number">14</span>]</div><div class="line">    quick_sort(nums, <span class="number">0</span>, len(nums) - <span class="number">1</span>)</div><div class="line">    print(nums)</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="归并排序——分治法的完美践行者"><a href="#归并排序——分治法的完美践行者" class="headerlink" title="归并排序——分治法的完美践行者"></a>归并排序——分治法的完美践行者</h4><ul>
<li><p>归并排序是一种利用分治思想实现的排序，也是一种效率很高的排序。其排序流程具体如下：</p>
<p><img src="http://img.blog.csdn.net/20170824095803142?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemhhb3NodWFpd2pt/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>如图所示：</p>
<ul>
<li>在归并排序的时候，我们将数组不断的拆分为两半，直到数据只剩一个的时候，然后再按照大小顺序把他们拼装起来。</li>
</ul>
</li>
<li><p>编码实现：</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge_sort</span><span class="params">(nums)</span>:</span></div><div class="line">    <span class="keyword">if</span> len(nums) == <span class="number">1</span>:</div><div class="line">        <span class="keyword">return</span> nums</div><div class="line">    mid = len(nums) // <span class="number">2</span></div><div class="line">    left = merge_sort(nums[:mid])</div><div class="line">    right = merge_sort(nums[mid:])</div><div class="line">    <span class="keyword">return</span> merge(left, right)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(left, right)</span>:</span></div><div class="line">    temp = []</div><div class="line">    left_p, right_p = <span class="number">0</span>, <span class="number">0</span></div><div class="line">    <span class="keyword">while</span> left_p &lt; len(left) <span class="keyword">and</span> right_p &lt; len(right):</div><div class="line">        <span class="keyword">if</span> left[left_p] &lt; right[right_p]:</div><div class="line">            temp.append(left[left_p])</div><div class="line">            left_p += <span class="number">1</span></div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            temp.append(right[right_p])</div><div class="line">            right_p += <span class="number">1</span></div><div class="line">    temp += (left[left_p:])</div><div class="line">    temp += (right[right_p:])</div><div class="line">    <span class="keyword">return</span> temp</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></div><div class="line">    numbers = [<span class="number">6</span>, <span class="number">3</span>, <span class="number">10</span>, <span class="number">5</span>, <span class="number">45</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">23</span>, <span class="number">4</span>, <span class="number">14</span>]</div><div class="line">    numbers = merge_sort(numbers)</div><div class="line">    print(numbers)</div></pre></td></tr></table></figure>
<p>  代码好像比之前的都要多一点，不过思路还是很简单的。主要是多了一个merge的过程：</p>
<ul>
<li>对于分别有序的两个数组，通过每次取出一个数据比较，将较小的那个放到新的数组中，较大的那个等待下次继续比较，就这样一直取，比较，取，比较，直到两个数组的数都放在了新的数组中。返回新的数组。</li>
<li>大体的流程还是通过递归实现的，其实大部分分治的算法都是通过递归搞定的，方便理解。<ul>
<li><strong>就效率而言，归并排序是六种排序中时间复杂度最好的，即使是最差情况，都是O(nlogn)，不过由于归并排序需要额外的空间，所以也是一种拿空间换时间的策略。</strong></li>
</ul>
</li>
</ul>
<h4 id="六大算法的效率比较"><a href="#六大算法的效率比较" class="headerlink" title="六大算法的效率比较"></a>六大算法的效率比较</h4><ul>
<li><p>排序</p>
<p>| 排序法     | 平均时间复杂度  | 最差情形        | 稳定度  | 额外空间     | 备注        |<br>| ——- | ——– | ———– | —- | ——– | ——— |<br>| 冒泡排序    | O(n2)    | O(n2)       | 稳定   | O(1)     | n小时较好     |<br>| 选择排序    | O(n2)    | O(n2)       | 不稳定  | O(1)     | n小时较好     |<br>| 插入排序    | O(n2)    | O(n2)       | 稳定   | O(1)     | 大部分已排序时较好 |<br>| Shell排序 | O(nlogn) | O(ns) 1&lt;s&lt;2 | 不稳定  | O(1)     | s是所选分组    |<br>| 快速排序    | O(nlogn) | O(n2)       | 不稳定  | O(nlogn) | n大时较好     |<br>| 归并排序    | O(nlogn) | O(nlogn)    | 稳定   | O(1)     | n大时较好     |</p>
</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/22/Hbase/Hbase的架构简单解析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="forever_zs">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/head.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="帅到没朋友">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/22/Hbase/Hbase的架构简单解析/" itemprop="url">Hbase的架构简单解析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-22T17:10:33+08:00">
                2017-08-22
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Hbase/" itemprop="url" rel="index">
                    <span itemprop="name">Hbase</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Hbase的架构简单解析"><a href="#Hbase的架构简单解析" class="headerlink" title="Hbase的架构简单解析"></a>Hbase的架构简单解析</h2><p>[TOC]</p>
<h4 id="Hbase内部的基本组成"><a href="#Hbase内部的基本组成" class="headerlink" title="Hbase内部的基本组成"></a>Hbase内部的基本组成</h4><ul>
<li><p>Hbase的整体主要由zookeeper，Hmaster，HRegionServer，Hdfs文件系统组成。由这四部分共同完成数据的读取与写入。</p>
</li>
<li><p>我们知道，hbase有个很重要的特性，可以通过分布式集群存取海量数据，当数据量越来越多的时候通过增加集群主机的数量就可以将数据分散到不同的主机上，这是传统的数据库很难实现的，那么hbase是如何做到的呢？下面我们就来解析下hbase的基本架构原理。</p>
</li>
</ul>
<h4 id="Hbase数据的存储方式"><a href="#Hbase数据的存储方式" class="headerlink" title="Hbase数据的存储方式"></a>Hbase数据的存储方式</h4><ul>
<li><p>对hbase有一点了解的童鞋都应该知道，hbase不同与传统的数据库，它是一种列式存储的数据库，对于里面的每一张表，每一行的数据都有一个rowkey，在数据库中的数据都是按照rowkey顺序排列的。所以可以将每张表的数据按照rowkey进行划分：</p>
<blockquote>
<p>不同的范围的数据划分到不同的地方（hbase中的这个地方被称为HRegion），不同的HRegion被放在不同的主机上，当查询数据的时候，只要根据rowkey先找到数据在那个范围的HRegion中，就可以直接到那个HRegion中找到数据，所以查询效率会比传统的数据库快很多。</p>
</blockquote>
<p><img src="http://www.uml.org.cn/zjjs/images/2012111323.png" alt="img"></p>
<p>基本就像上图这样，随着数据不断增多，Region也会不断的增多（对表的划分增多），不同的Region由多个不同的RegionServer管理着。</p>
</li>
</ul>
<h4 id="Hbase读写数据的基本流程"><a href="#Hbase读写数据的基本流程" class="headerlink" title="Hbase读写数据的基本流程"></a>Hbase读写数据的基本流程</h4><ul>
<li><p>写数据</p>
<p><img src="http://img.blog.csdn.net/20170822151914513?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemhhb3NodWFpd2pt/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<ol>
<li>首先要找到管理相应Region的RegionServer（但是如何找到RegionServer的呢？这个会在读取数据哪里解释），然后发送写数据的请求。</li>
<li>当RegionServer收到请求后，首先会将请求写入到HLog中（防止数据意外丢失，很多系统都是利用的这种机制）。</li>
<li>在Hlog写入完成之后，在找到相应的Region将数据写入。</li>
</ol>
<p>那么问题来了？在Region内部又是如何将数据写入到hdfs中的呢？这里就涉及到Region内部的数据持久化机制了：</p>
<p><img src="http://img.blog.csdn.net/20170822153828380?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemhhb3NodWFpd2pt/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>在Region内部，当数据操作请求由RegionServer传到Region的时候，Region中包含了很多的Store（每个Store对应了一个Table在这个Region中的一个Column Family，即每个Column Family就是一个集中的存储单元），写入数据根据具体在那个Column Family，将数据传到具体的Store中。数据传输流程如下：</p>
<ol>
<li>RegionServer首先会将数据写入到MemStore内存中，这时返回客户端通知说已经写入成功了。</li>
<li>当MemStore中的数据达到一定大小的时候，会有一次flush的过程，在此过程中，数据会被写入StoreFile文件中。然后StoreFile又会被序列化为HFile文件。（备注：在写入MemStore的时候会被插入到指定的顺序中，所以是有序的）</li>
<li>HFile之后通过Hdfs的api上传到hdfs中。</li>
</ol>
</li>
<li><p>读数据流程</p>
<p>首先我们需要思考的是，要想读到数据，首先客户端肯定需要知道数据在哪吧。（写数据同样也是要先知道数据在哪），我们已经知道，hbase的数据都划分到了region中，那么我们如何找到相应的region呢？整体流程如下图：</p>
<p><img src="http://img.blog.csdn.net/20170822160744968?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemhhb3NodWFpd2pt/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<ol>
<li>首先我们要通过zookeeper找找到-root-的位置，这个root本质上也是一个region，不过里面存放的是不同范围的rowkey应该去那个RegionServer的<code>.meta.</code>中去查找</li>
<li>通过请求<code>.meta.</code>我们知道了我们需要的region在哪个RegionServer上，然后就可以去那个regionServer上去读数据了。</li>
</ol>
</li>
</ul>
<p>注1：这里其实有个问题，为啥不直接把数据的region所在的信息写在-root-中，这样不就少一个流程了。加快了访问速度吗？主要是为了保存的数据量考虑，由于Region的数量可能会有很多，而-root-只能由一个，所以防止-root-的内存被撑爆，所以多加了一层。</p>
<p>注2：不过一般公司的数据真的有这么多吗？应该是没有的吧，因而在HBase 0.96以后去掉了-ROOT- Table，只剩下这个特殊的目录表叫做Meta Table(hbase:meta)，它存储了集群中所有用户HRegion的位置信息，而ZooKeeper的节点中(/hbase/meta-region-server)存储的则直接是这个Meta Table的位置</p>
<h4 id="Hmaster是干嘛的？"><a href="#Hmaster是干嘛的？" class="headerlink" title="Hmaster是干嘛的？"></a>Hmaster是干嘛的？</h4><ul>
<li><p>在上面的读写流程中，我们已经提到了HRegionServer，hdfs，zookeeper的作用了，但是一直都没有提到Hmaster，这个听上去很像老大的东西到底是干嘛的呢？难道只是打酱油的？Ofcource Not！</p>
<p><img src="http://img.blog.csdn.net/20170822161823959?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemhhb3NodWFpd2pt/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>之前我们虽然已经知道了数据是如何存入的，但是有一个问题一直没说，那就是hbase为啥可以管理海量数据呢？当数据越来越多的时候，是谁来负责将数据进行划分为更小的区域的呢？那就是一直在默默奉献额老大——HMaster。</p>
</li>
<li><p>Hmaster是如何管理数据的呢？</p>
<ol>
<li><p>清理冗余的数据</p>
<p>当同一region的数据块达到四块的时候，Hmaster会对其进行一次数据合并，清理期中的冗余数据。合并之后的数据会小于256M。</p>
</li>
<li><p>HRegion Split</p>
<ul>
<li>最初，一个Table只有一个HRegion，随着数据写入增加，如果一个HRegion到达一定的大小，就需要Split成两个HRegion，这个大小由hbase.hregion.max.filesize指定。这个Split过程就是由Hmaster完成的。</li>
<li>当split时，两个新的HRegion会在同一个HRegionServer中创建，它们各自包含父HRegion一半的数据，当Split完成后，父HRegion会下线，而新的两个子HRegion会向HMaster注册上线，处于负载均衡的考虑，这两个新的HRegion可能会被HMaster分配到其他的HRegionServer中。</li>
</ul>
</li>
<li><p>当HRegionServer宕机之后，hmaster可以读取hlog，将数据在发送给其他RegionServer进行数据恢复。并修改<code>.meta.</code></p>
</li>
</ol>
<p>注：RegionServer不管理Hbase的元数据，元数据由Zookeeper管理。</p>
</li>
</ul>
<h4 id="总结一下"><a href="#总结一下" class="headerlink" title="总结一下"></a>总结一下</h4><ul>
<li><p>Hbase中各个主要部分的功能：</p>
<p><img src="http://www.blogjava.net/images/blogjava_net/dlevin/HBaseArch1.jpg" alt="img"></p>
<ol>
<li><p>Hmater</p>
<blockquote>
<ul>
<li>在Region Split后，负责新Region的分配； </li>
<li>新机器加入时，管理HRegion Server的负载均衡，调整Region分布</li>
<li>在HRegion Server宕机后，负责失效HRegion Server 上的Regions迁移。</li>
</ul>
</blockquote>
</li>
<li><p>Region Server</p>
<blockquote>
<ul>
<li>Region server维护Master分配给它的region，处理对这些region的IO请求</li>
<li>HRegion Server管理了很多table的分区，也就是region。</li>
</ul>
</blockquote>
</li>
<li><p>zookeeper</p>
<blockquote>
<ul>
<li>ZooKeeper为HBase集群提供协调服务，它管理着HMaster和HRegionServer的状态(available/alive等)，并且会在它们宕机时通知给HMaster</li>
<li>zookeeper中管理着hbase的元数据，例如-root-的位置所在。</li>
</ul>
</blockquote>
</li>
<li><p>hdfs</p>
<blockquote>
<ul>
<li>数据文件的存放处。由于其本身的分布式存储机制，所以数据文件很安全。</li>
<li>hadoop的datanode最好和region在同一主机上，方便读取数据。尽量避免网络数据传输。</li>
</ul>
</blockquote>
</li>
</ol>
</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/20/Hbase/Hbase入门/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="forever_zs">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/head.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="帅到没朋友">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/20/Hbase/Hbase入门/" itemprop="url">Hbase入门</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-20T20:10:33+08:00">
                2017-08-20
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Hbase/" itemprop="url" rel="index">
                    <span itemprop="name">Hbase</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Hbase入门"><a href="#Hbase入门" class="headerlink" title="Hbase入门"></a>Hbase入门</h2><p>[TOC]</p>
<h4 id="Hbase是干嘛的？"><a href="#Hbase是干嘛的？" class="headerlink" title="Hbase是干嘛的？"></a>Hbase是干嘛的？</h4><ul>
<li>HBASE是一个高可靠性、高性能、面向列、可伸缩的分布式存储系统。其主要作用是通过分布式的集群系统进行海量数据的存储与处理。其主要的优点有：<ol>
<li>线性扩展，随着数据量增多可以通过节点扩展进行支撑</li>
<li>数据存在hdfs上面，备份机制健全</li>
<li>通过zookeeper协调查找数据，读取速度快。</li>
<li>良好的数据备份与恢复机制，数据安全性由保障。</li>
</ol>
</li>
</ul>
<h4 id="Hbase的安装与配置"><a href="#Hbase的安装与配置" class="headerlink" title="Hbase的安装与配置"></a>Hbase的安装与配置</h4><ol>
<li><p>下载安装包并解压，然后修改环境变量</p>
</li>
<li><p>修改hbase-env.sh配置文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"># The java implementation to use.  Java 1.7+ required.</div><div class="line">export JAVA_HOME=/usr/local/soft/jdk1.8.0_144</div><div class="line"># Extra Java CLASSPATH elements.  Optional.</div><div class="line">export HBASE_CLASSPATH=/usr/local/soft/hbase/conf</div><div class="line">export JAVA_CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar</div><div class="line">export HBASE_OPTS=&quot;-XX:+UseConcMarkSweepGC&quot;</div><div class="line"># 告诉habse用我们自己配置的zookeeper</div><div class="line"> export HBASE_MANAGES_ZK=false</div></pre></td></tr></table></figure>
</li>
<li><p>修改hbase-site.xml</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>hbase.master<span class="tag">&lt;/<span class="name">name</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>mini1:60000<span class="tag">&lt;/<span class="name">value</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>hbase.master.maxclockskew<span class="tag">&lt;/<span class="name">name</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>180000<span class="tag">&lt;/<span class="name">value</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>hbase.rootdir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>hdfs://mini1:9000/hbase<span class="tag">&lt;/<span class="name">value</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">name</span>&gt;</span>hbase.zookeeper.property.clientPort<span class="tag">&lt;/<span class="name">name</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">value</span>&gt;</span>2181<span class="tag">&lt;/<span class="name">value</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">description</span>&gt;</span>Property from ZooKeeper's config zoo.cfg.<span class="tag">&lt;/<span class="name">description</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line"> 	<span class="comment">&lt;!--是否采用分布式策略--&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>hbase.cluster.distributed<span class="tag">&lt;/<span class="name">name</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">value</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line">  	<span class="comment">&lt;!--zookeeper所在位置--&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>hbase.zookeeper.quorum<span class="tag">&lt;/<span class="name">name</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>mini5,mini6,mini7<span class="tag">&lt;/<span class="name">value</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>hbase.zookeeper.property.dataDir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>/home/hadoop/hbase/tmp/zookeeper<span class="tag">&lt;/<span class="name">value</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></div></pre></td></tr></table></figure>
</li>
<li><p>启动hbase</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">start-hbase.sh</div></pre></td></tr></table></figure>
</li>
<li><p>打开shell交互式命令行</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">hbase shell</div><div class="line"><span class="meta">#</span> web管理打开地址 http://mini1:16030</div></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a>常见错误</h4><ol>
<li><p>发现<code>ERROR: org.apache.hadoop.hbase.ipc.ServerNotRunningYetException: Server is not running yet</code>，一般是hdfs正处于安全模式，可以直接关闭（感觉不太好）:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hadoop dfsadmin -safemode leave</div></pre></td></tr></table></figure>
<p>​</p>
</li>
</ol>
<h4 id="基本数据模型"><a href="#基本数据模型" class="headerlink" title="基本数据模型"></a>基本数据模型</h4><ol>
<li><p><strong>Row Key</strong></p>
<blockquote>
<p>key是用来检索记录的主键,，通过row key来定位数据。是最重要的数据模型，当插入数据的时候，数据会按照row key进行排序，插入到合适的位置。</p>
</blockquote>
</li>
<li><p><strong>Columns Family</strong></p>
<blockquote>
<p>HBASE表中的每个列，都归属于某个列族。列族是表的schema的一部 分(而列不是)，必须在使用表之前定义。列名都以列族作为前缀。例如 courses:history，courses:math都属于courses 这个列族。</p>
</blockquote>
</li>
<li><p><strong>Cell</strong></p>
<blockquote>
<p>由{row key, columnFamily, version} 唯一确定的单元。cell中 的数据是没有类型的，全部是<strong>字节码</strong>形式存贮。</p>
</blockquote>
</li>
<li><p><strong>TimeStamp</strong></p>
<blockquote>
<p>HBASE中通过rowkey和columns确定的为一个存贮单元称为cell。每个 cell都保存 着同一份数据的多个版本。版本通过时间戳来索引。时间戳的类型是 64位整型。时间戳可以由HBASE(在数据写入时自动 )赋值。</p>
</blockquote>
</li>
</ol>
<h4 id="Hbase的常用命令"><a href="#Hbase的常用命令" class="headerlink" title="Hbase的常用命令"></a>Hbase的常用命令</h4><table>
<thead>
<tr>
<th><strong>名称</strong></th>
<th><strong>命令表达式</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>创建表</strong></td>
<td><strong>create ‘表名’, ‘列族名1’,’列族名2’,’</strong>列族名N’</td>
</tr>
<tr>
<td><strong>查看所有表</strong></td>
<td><strong>list</strong></td>
</tr>
<tr>
<td><strong>描述表</strong></td>
<td><strong>describe</strong>  ‘表名’</td>
</tr>
<tr>
<td>判断表存在</td>
<td><strong>exists</strong>  ’表名‘</td>
</tr>
<tr>
<td>判断是否禁用启用表</td>
<td><strong>is_enabled</strong> ‘表名’  <strong>is_disabled</strong> ‘表名’</td>
</tr>
<tr>
<td><strong>添加记录      </strong></td>
<td><strong>put</strong>   ‘表名’, ‘rowKey’, ‘列族 :列‘  ,  ‘值’</td>
</tr>
<tr>
<td>查看记录rowkey下的所有数据</td>
<td><strong>get   ‘</strong>表名’ , ‘rowKey’</td>
</tr>
<tr>
<td><strong>查看表中的记录总数</strong></td>
<td><strong>count   ‘表名’</strong></td>
</tr>
<tr>
<td><strong>获取某个列族</strong></td>
<td><strong>get</strong> ‘表名’,’rowkey’,’列族’</td>
</tr>
<tr>
<td><strong>获取某个列族的某个列</strong></td>
<td><strong>get</strong> ‘表名’,’rowkey’,’列族：列’</td>
</tr>
<tr>
<td><strong>删除记录</strong></td>
<td><strong>delete   **</strong>‘表名’ ,‘行名’ , ‘列族：列’</td>
</tr>
<tr>
<td><strong>删除整行</strong></td>
<td><strong>deleteall ‘**</strong>表名’,’rowkey’</td>
</tr>
<tr>
<td><strong>删除一张表</strong></td>
<td><strong>先要屏蔽该表，才能对该表进行删除</strong>  <strong>第一步 disable ‘表名’ ，第二步  drop ‘</strong>表名’</td>
</tr>
<tr>
<td><strong>清空表</strong></td>
<td><strong>truncate ‘</strong>表名’</td>
</tr>
<tr>
<td><strong>查看所有记录</strong></td>
<td><strong>scan “</strong>表名”</td>
</tr>
</tbody>
</table>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/11/netty/基于netty的rpc框架/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="forever_zs">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/head.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="帅到没朋友">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/11/netty/基于netty的rpc框架/" itemprop="url">基于netty的rpc框架</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-11T20:10:33+08:00">
                2017-08-11
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/netty框架/" itemprop="url" rel="index">
                    <span itemprop="name">netty框架</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="基于netty的rpc框架"><a href="#基于netty的rpc框架" class="headerlink" title="基于netty的rpc框架"></a>基于netty的rpc框架</h2><p>[TOC]</p>
<h4 id="如果你已经对以下东东有所了解，那么你就可以完成一个rpc框架了"><a href="#如果你已经对以下东东有所了解，那么你就可以完成一个rpc框架了" class="headerlink" title="如果你已经对以下东东有所了解，那么你就可以完成一个rpc框架了"></a>如果你已经对以下东东有所了解，那么你就可以完成一个rpc框架了</h4><ul>
<li>Java的反射技术</li>
<li>java的动态代理机制</li>
<li>基于nio的框架netty</li>
<li>全世界最好的框架-spring</li>
<li>java的序列化</li>
</ul>
<h4 id="神马是rpc？"><a href="#神马是rpc？" class="headerlink" title="神马是rpc？"></a>神马是rpc？</h4><ul>
<li><p>在这个大数据时代，很多公司的服务器都是以集群的方式存在的。在我们传统的mvc后台开发中，我们就需要把不同层的服务部署到不同的服务器上面，这个每个服务器的的压力就会比较小了。</p>
<p>但是这样也会带来一个问题——我在这台机器上如何才能调用到另一台机器的代码呢？这是个问题。</p>
<p>我们先来举个栗子：</p>
<p><img src="http://img.blog.csdn.net/20170810174003466?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemhhb3NodWFpd2pt/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>比如我们在一个传统mvc项目中，我们有一个UserController处理用户的请求，假如它长的这个样子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@RestController</span></div><div class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/user"</span>)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Autowired</span></div><div class="line">    UserService userService;</div><div class="line"></div><div class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"/current"</span>)</div><div class="line">    <span class="function"><span class="keyword">public</span> AjaxResponse <span class="title">login</span><span class="params">(String name,String password)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> AjaxResponse.success(userService.login(name,password));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>正常情况下，这个UserService的实现肯定是在同一个项目或者是本地的，早就已经被加入到spring容器中了，不过加入我们为了减少服务器的压力，我们将UserService的实现放到另一台服务器上，加入我们有一个膜法，可以在本地的Controller像调用本地方法一样调用另一台的userServiceImpl就好了，Rpc就是这样一种技术。</p>
</li>
</ul>
<h4 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h4><ul>
<li><p>表面上看这是一个很难完成的任务，本机怎么可能可以调用到远程的方法呢？不过如果我们这个任务拆分开来，就会发现只要一步一步来，其实还是挺简单的。</p>
<blockquote>
<p>我们可以换一种思路，既然直接调用不行，我们可以曲线救国呀，我们只要把调用方法的对象的名称，方法的名字，方法的参数与方法的类型都通过网络发送到另一台机器上，另一条机器接收到之后根据请求信息调用该对象的方法，然后在把执行结果通过网路直接返回回来不就ok了。其实，rpc框架的大体思路就是如此。</p>
</blockquote>
</li>
<li><p>大体实现流程如下：</p>
<ol>
<li>通过java的动态代理机制为我们UserService创建代理对象，在代理对象执行方法的时候实际上已经被我们定制的方法拦截。</li>
<li>在拦截的逻辑里面，我们在获取到调用的方法的所有接口，方法名，参数集合，参数类型集合后封装到一个JavaBean——request中去，然后我们将这个对象序列化之后通过网络传输到另一台机器上。</li>
<li>另一台机器接受到这个网络请求后，将数据反序列化为Request对象，从而了解我们请求的是具体是什么对象的什么方法，然后服务器通过反射的方式调用，并将执行结果通过另一个JavaBean——Response返回。</li>
<li>本机收到服务端的返回。整个rpc调用就完成了。</li>
</ol>
</li>
<li><p>如下图所示，由于画图水平有限，不过大致就是这个意思：</p>
<p><img src="http://img.blog.csdn.net/20170811092454428?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemhhb3NodWFpd2pt/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
</li>
</ul>
<h4 id="代码具体实现"><a href="#代码具体实现" class="headerlink" title="代码具体实现"></a>代码具体实现</h4><ol>
<li><p>首先我们需要为我们的网络请求分装两个JavaBean，分别为Request与Response.。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//在Request中应有的属性</span></div><div class="line"><span class="keyword">private</span> String requestId;</div><div class="line"><span class="keyword">private</span> String className;</div><div class="line"><span class="keyword">private</span> String methodName;</div><div class="line"><span class="keyword">private</span> Class&lt;?&gt;[] parameterTypes;</div><div class="line"><span class="keyword">private</span> Object[] parameters;</div><div class="line"><span class="comment">//在response应该有的属性</span></div><div class="line"><span class="keyword">private</span> String requestId;</div><div class="line"><span class="keyword">private</span> Throwable error;</div><div class="line"><span class="keyword">private</span> Object result;</div></pre></td></tr></table></figure>
</li>
<li><p>创建RpcClient，封装我们的网络请求流程。其中最重要的是这个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Response <span class="title">send</span><span class="params">(Request request)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">        ClientBootstrap bootstrap = <span class="keyword">new</span> ClientBootstrap();</div><div class="line">        ExecutorService boss = Executors.newCachedThreadPool();</div><div class="line">        ExecutorService work = Executors.newCachedThreadPool();</div><div class="line"></div><div class="line">        bootstrap.setFactory(<span class="keyword">new</span> NioClientSocketChannelFactory(boss,work));</div><div class="line">        bootstrap.setPipelineFactory(<span class="keyword">new</span> ChannelPipelineFactory() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> ChannelPipeline <span class="title">getPipeline</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">                ChannelPipeline pipeline = Channels.pipeline();</div><div class="line">                pipeline.addLast(<span class="string">"decoder"</span>,<span class="keyword">new</span> ResponseDecoder());</div><div class="line">                pipeline.addLast(<span class="string">"encoder"</span>,<span class="keyword">new</span> RequestEncoder());</div><div class="line">                pipeline.addLast(<span class="string">"handler"</span>,RpcClient.<span class="keyword">this</span>);</div><div class="line">                <span class="keyword">return</span> pipeline;</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">        ChannelFuture connect = bootstrap.connect(<span class="keyword">new</span> InetSocketAddress(address, port)).sync();</div><div class="line">        connect.getChannel().write(request).sync();</div><div class="line">  		<span class="comment">//阻塞线程直到完成请求或者请求失败</span></div><div class="line">        <span class="keyword">synchronized</span> (obj)&#123;</div><div class="line">            obj.wait();</div><div class="line">        &#125;</div><div class="line">        connect.getChannel().close().sync();</div><div class="line"></div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.response;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>这里用netty3进行的网咯请求，这里<code>ResponseDecoder</code>与<code>RequestEncoder</code>是对Response与Request进行的序列化与反序列化，采用的谷歌的Protostuff序列化框架实现（为啥不用java自带的序列化工具呢？因为java自定的序列化附带了很多其他信息，序列化的字节长度比谷歌的长好几倍，所以是为了节约带宽，同时Protostuff的序列化支持多种编程语言）</p>
</li>
<li><p>创建代理的工具类，返回代理对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> &lt;T&gt;<span class="function">T <span class="title">proxy</span><span class="params">(Class&lt;?&gt; clazz)</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> (T) Proxy.newProxyInstance(clazz.getClassLoader(), <span class="keyword">new</span> Class&lt;?&gt;[] &#123; clazz &#125;, <span class="keyword">new</span> InvocationHandler() &#123;</div><div class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line">                Request request = <span class="keyword">new</span> Request();</div><div class="line">                request.setClassName(method.getDeclaringClass().getName());</div><div class="line">                request.setMethodName(method.getName());</div><div class="line">                request.setParameters(args);</div><div class="line">                request.setRequestId(UUID.randomUUID().toString());</div><div class="line">                request.setParameterTypes(method.getParameterTypes());</div><div class="line">                RpcClient client =<span class="keyword">new</span> RpcClient(address,port);</div><div class="line">              	<span class="comment">//通过封装的网络框架进行网络请求</span></div><div class="line">                Response response = client.send(request);</div><div class="line">                <span class="keyword">if</span> (response.getError()!=<span class="keyword">null</span>)&#123;</div><div class="line">                    <span class="keyword">throw</span> response.getError();</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">else</span>&#123;</div><div class="line">                    <span class="keyword">return</span> response;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>服务端在开启服务的时候就需要通过spring扫描所有的service实现类，将其装进spring的容器中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException </span>&#123;</div><div class="line">        Map&lt;String, Object&gt; beansWithAnnotation = applicationContext.getBeansWithAnnotation(RPCService.class);</div><div class="line">        <span class="keyword">for</span>(Map.Entry&lt;String,Object&gt; entry :beansWithAnnotation.entrySet())&#123;</div><div class="line">            String interfaceName = entry.getValue().getClass()</div><div class="line">                    .getAnnotation(RPCService.class).value().getName();</div><div class="line">            serviceMap.put(interfaceName,entry.getValue());</div><div class="line">        &#125;</div><div class="line">        startServer();</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>需要发布的服务类都需要使用<code>@RPCService</code>注解，这是一个自定义的注解。</p>
</li>
<li><p>在服务端收到客户端的网络请求之后，我们就需要从spring容器中找到请求的服务类完成调用并返回执行结果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">messageReceived</span><span class="params">(ChannelHandlerContext ctx, MessageEvent event)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        Request request = (Request) event.getMessage();</div><div class="line">        Response response = <span class="keyword">new</span> Response();</div><div class="line">        <span class="comment">//调用请求类的请求方法执行并返回执行结果</span></div><div class="line">        Object invoke = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            Object requestBean = serviceMap.get(request.getClassName());</div><div class="line">            Class&lt;?&gt; requestClazz = Class.forName(request.getClassName());</div><div class="line">            Method method = requestClazz.getMethod(request.getMethodName(), request.getParameterTypes());</div><div class="line">            invoke = method.invoke(requestBean, request.getParameters());</div><div class="line">            response.setRequestId(UUID.randomUUID().toString());</div><div class="line">            response.setResult(invoke);</div><div class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">            response.setError(e);</div><div class="line">            response.setRequestId(UUID.randomUUID().toString());</div><div class="line">        &#125;</div><div class="line">        System.out.println(request+<span class="string">""</span>+response);</div><div class="line">        <span class="comment">//返回执行结果</span></div><div class="line">        ctx.getChannel().write(response);</div><div class="line"></div><div class="line">    &#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul>
<li>整体的流程还是比较简单的，就是具体实现的时候会有一些细节问题需要好好处理。虽然是第一次写这种轮子程序，不过感觉还是不错的。完整代码已上传到<a href="https://github.com/forever-zs/MiniRpc" target="_blank" rel="external">我的GitHub</a>仓库里面，有兴趣的小伙伴可以去看看。</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/06/zookeeper/动态感知服务器上下线/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="forever_zs">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/head.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="帅到没朋友">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/06/zookeeper/动态感知服务器上下线/" itemprop="url">通过zookeeper完成动态感知分布式服务器务器上下线的功能</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-06T09:10:33+08:00">
                2017-08-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/zookeeper/" itemprop="url" rel="index">
                    <span itemprop="name">zookeeper</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="通过zookeeper完成动态感知分布式服务器上下线的功能"><a href="#通过zookeeper完成动态感知分布式服务器上下线的功能" class="headerlink" title="通过zookeeper完成动态感知分布式服务器上下线的功能"></a>通过zookeeper完成动态感知分布式服务器上下线的功能</h2><p>[TOC]</p>
<h4 id="业务描述"><a href="#业务描述" class="headerlink" title="业务描述"></a>业务描述</h4><ul>
<li>某分布式系统中，主节点可以有多台，可以动态上下线，任意一台客户端都能实时感知到主节点服务器的上下线。当主节点下线的时候，客户端会收到通知，并更新目前在还在线的主节点host信息，可以防止客户端向已经挂掉的节点进行请求。</li>
</ul>
<h4 id="服务器端的实现"><a href="#服务器端的实现" class="headerlink" title="服务器端的实现"></a>服务器端的实现</h4><ul>
<li><p>要想完成上述功能，在我们可以想到通过zookeeper的短暂态的节点完成，在服务器启动的时候，我们连接到zookeeper并向其注册一个短暂态的节点，当服务器因为某种意外宕机的时候，这个节点也会被删除，这样客户端访问所有的注册节点的信息，就是仍然在正常工作的主节点。</p>
</li>
<li><p>服务器端的代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.io.IOException;</div><div class="line"></div><div class="line"><span class="keyword">import</span> org.apache.zookeeper.CreateMode;</div><div class="line"><span class="keyword">import</span> org.apache.zookeeper.KeeperException;</div><div class="line"><span class="keyword">import</span> org.apache.zookeeper.WatchedEvent;</div><div class="line"><span class="keyword">import</span> org.apache.zookeeper.Watcher;</div><div class="line"><span class="keyword">import</span> org.apache.zookeeper.ZooDefs.Ids;</div><div class="line"><span class="keyword">import</span> org.apache.zookeeper.ZooKeeper;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClusterServer</span> </span>&#123;</div><div class="line">	</div><div class="line">  	<span class="comment">//zookeeper的ip与端口，这里是zookeeper是一个集群</span></div><div class="line">	<span class="keyword">private</span> String ZK_SERVER_LIST = <span class="string">"mini1:2181,mini2:2181,mini3:2181"</span>;</div><div class="line">	<span class="comment">//设置超时时间，当主节点2s后没反应就认该节点已经挂了</span></div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> sessionTimeout = <span class="number">2000</span>;</div><div class="line">	<span class="comment">//所有的注册节点信息当道/servers下面，方便管理</span></div><div class="line">	<span class="keyword">private</span> String SERVER_DIR = <span class="string">"/servers"</span>;</div><div class="line">	</div><div class="line">	<span class="keyword">private</span> ZooKeeper zk;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">		</div><div class="line">		zk = <span class="keyword">new</span> ZooKeeper(ZK_SERVER_LIST, sessionTimeout, <span class="keyword">new</span> Watcher() &#123;</div><div class="line">			</div><div class="line">			<span class="comment">//当zookeeper服务器集群有断线时会调用</span></div><div class="line">			<span class="meta">@Override</span></div><div class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent event)</span> </span>&#123;</div><div class="line">				<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">				System.out.println(event.toString());</div><div class="line">			&#125;</div><div class="line">		&#125;);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(String hontname)</span> <span class="keyword">throws</span> IOException, KeeperException, InterruptedException </span>&#123;</div><div class="line">		<span class="comment">//创建瞬时态且带序号的节点，这样在节点下线后该节点就会被删除</span></div><div class="line">		String result = zk.create(SERVER_DIR+<span class="string">"/server"</span>, hontname.getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL);</div><div class="line">		</div><div class="line">		System.out.println(<span class="string">"创建结果："</span>+result);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">diy</span><span class="params">()</span></span>&#123;</div><div class="line">		System.out.println(<span class="string">"just do it"</span>);</div><div class="line">		<span class="keyword">try</span> &#123;</div><div class="line">			Thread.sleep(Integer.MAX_VALUE);</div><div class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">			<span class="comment">// TODO Auto-generated catch block</span></div><div class="line">			e.printStackTrace();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, KeeperException, InterruptedException </span>&#123;</div><div class="line">		ClusterServer server =<span class="keyword">new</span> ClusterServer();</div><div class="line">		server.connect();</div><div class="line">		server.register(args[<span class="number">0</span>]);</div><div class="line">		server.diy();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>程序启动的时候就向服务器把当前主节点的host信息注册到zookeeper中。</p>
</li>
<li><p>这里的hostname本来可以通过java api进行动态获取的，不过为了方便实验就省略了。</p>
</li>
</ul>
<h4 id="客户端的实现"><a href="#客户端的实现" class="headerlink" title="客户端的实现"></a>客户端的实现</h4><ul>
<li><p>客户端所需要的工作是获取正常工作的主节点并且当主节点发生变化的时候可以收到信息，获取最新的正常工作的主节点。所以我们可以对<code>servers</code>下面的子节点信息进行监听，</p>
</li>
<li><p>代码实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.io.IOException;</div><div class="line"><span class="keyword">import</span> java.util.ArrayList;</div><div class="line"><span class="keyword">import</span> java.util.List;</div><div class="line"></div><div class="line"><span class="keyword">import</span> org.apache.zookeeper.KeeperException;</div><div class="line"><span class="keyword">import</span> org.apache.zookeeper.WatchedEvent;</div><div class="line"><span class="keyword">import</span> org.apache.zookeeper.Watcher;</div><div class="line"><span class="keyword">import</span> org.apache.zookeeper.ZooKeeper;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClusterClient</span> </span>&#123;</div><div class="line">	<span class="keyword">private</span> String ZK_SERVER_LIST = <span class="string">"mini1:2181,mini2:2181,mini3:2181"</span>;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> sessionTimeout = <span class="number">2000</span>;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> String SERVER_DIR = <span class="string">"/servers"</span>;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> ZooKeeper zk;</div><div class="line">	</div><div class="line">	<span class="keyword">private</span> List&lt;String&gt; servers=<span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">		zk = <span class="keyword">new</span> ZooKeeper(ZK_SERVER_LIST, sessionTimeout, <span class="keyword">new</span> Watcher() &#123;</div><div class="line"></div><div class="line">			<span class="meta">@Override</span></div><div class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent event)</span> </span>&#123;</div><div class="line">				System.out.println(event.toString());</div><div class="line">				<span class="keyword">try</span> &#123;</div><div class="line">                  	<span class="comment">//收到通知后再次对服务器设置监听。</span></div><div class="line">					getServerList();</div><div class="line">					System.out.println(servers);</div><div class="line">				&#125; <span class="keyword">catch</span> (KeeperException | InterruptedException e) &#123;</div><div class="line">                  	</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">  	<span class="comment">//获取服务器列表并设置监听</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getServerList</span><span class="params">()</span> <span class="keyword">throws</span> KeeperException, InterruptedException</span>&#123;</div><div class="line">		List&lt;String&gt; nodeList = zk.getChildren(SERVER_DIR,<span class="keyword">true</span>);</div><div class="line">		servers.clear();</div><div class="line">		<span class="keyword">for</span>(String node:nodeList)&#123;</div><div class="line">			<span class="keyword">byte</span> []data = zk.getData(SERVER_DIR+<span class="string">"/"</span>+node, <span class="keyword">false</span>, <span class="keyword">null</span>);</div><div class="line">			String hostName = <span class="keyword">new</span> String(data);</div><div class="line">			servers.add(hostName);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">  	<span class="comment">//做自己爱做的事同时完成守护进程的功能</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">diy</span><span class="params">()</span></span>&#123;</div><div class="line">		<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">			</div><div class="line">			<span class="meta">@Override</span></div><div class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">				<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">				<span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</div><div class="line">					</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;).start();;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, KeeperException, InterruptedException </span>&#123;</div><div class="line">		ClusterClient client =<span class="keyword">new</span> ClusterClient();</div><div class="line">		client.connect();</div><div class="line">		client.getServerList();</div><div class="line">		client.diy();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><ul>
<li><p>我们可以在多个终端分别运行服务器程序，用来模拟多个主节点，直接关闭终端模仿主节点的宕机。</p>
</li>
<li><p>实验结果如下（当我们动态增加节点的结果）：</p>
<p><img src="http://img.blog.csdn.net/20170806173020943?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemhhb3NodWFpd2pt/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
</li>
<li><p>所有需要的jar包在zookeeper的解压包里面都有。或者直接在我的<a href="https://github.com/forever-zs/DynamicServiceMonitor" target="_blank" rel="external">github</a>里面有代码以及jar包。</p>
<p>​</p>
</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/05/zookeeper/ZooKeeper/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="forever_zs">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/head.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="帅到没朋友">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/05/zookeeper/ZooKeeper/" itemprop="url">zookeeper入门</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-05T09:10:33+08:00">
                2017-08-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/zookeeper/" itemprop="url" rel="index">
                    <span itemprop="name">zookeeper</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="zookeeper入门"><a href="#zookeeper入门" class="headerlink" title="zookeeper入门"></a>zookeeper入门</h2><p>[TOC]</p>
<h4 id="zookeeper的简介"><a href="#zookeeper的简介" class="headerlink" title="zookeeper的简介"></a>zookeeper的简介</h4><p>顾名思义，zookeeper就是动物园管理员的意思，Zookeeper是一个分布式协调服务；就是为用户的分布式应用程序提供协调服务。其主要具有一下特点：</p>
<ol>
<li>zookeeper是为别的分布式程序服务的</li>
<li>Zookeeper本身就是一个分布式程序（只要有半数以上节点存活，zk就能正常服务）</li>
<li>Zookeeper所提供的服务涵盖：主从协调、服务器节点动态上下线、统一配置管理、分布式共享锁、统一名称等服务。</li>
</ol>
<p>虽然说可以提供各种服务，但是zookeeper在底层其实只提供了两个功能：</p>
<ol>
<li>管理(存储，读取)用户程序提交的<strong>元数据</strong>（不是用户程序的业务数据）；</li>
<li>并为用户程序提供数据节点监听服务；（监听因故宕机的程序，并通知其他应用程序接替工作）。</li>
</ol>
<h4 id="zookeeper的特性"><a href="#zookeeper的特性" class="headerlink" title="zookeeper的特性"></a>zookeeper的特性</h4><ol>
<li><p>Zookeeper：一个leader，多个follower组成的集群</p>
</li>
<li><p>全局数据一致：每个server保存一份相同的数据副本，client无论连接到哪个server，数据都是一致的</p>
</li>
<li><p>分布式读写，更新请求转发，由leader实施</p>
</li>
<li><p>更新请求顺序进行，来自同一个client的更新请求按其发送顺序依次执行</p>
</li>
<li><p>数据更新原子性，一次数据更新要么成功，要么失败</p>
</li>
<li><p>实时性，在一定时间范围内，client能读到最新数据</p>
</li>
</ol>
<h4 id="zookeeper环境搭建"><a href="#zookeeper环境搭建" class="headerlink" title="zookeeper环境搭建"></a>zookeeper环境搭建</h4><ol>
<li><p>拷贝安装包到对应服务器上。</p>
</li>
<li><p>解压缩安装包</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">tar -zvxf zookeeper-3.4.5.tar.gz</div><div class="line">mv zookeeper-3.4.5 zookeeper #修改文件夹名称</div></pre></td></tr></table></figure>
</li>
<li><p>配置环境变量</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">vim /etc/profile</div><div class="line"><span class="meta">#</span>加入以下信息</div><div class="line">export ZOOKEEPER_HOME=/opt/zookeeper</div><div class="line">export PATH=$PATH:$JAVA_HOME/bin:$HADOOP_HOME/bin:$HADOOP_HOME/sbin:$HIVE_HOME/bin:$ZOOKEEPER_HOME/bin</div><div class="line"><span class="meta">#</span>添加之后</div><div class="line">source /etc/profile</div></pre></td></tr></table></figure>
</li>
<li><p>修改conf文件夹下的配置文件（复制zoo_sample.xml为zoo.xml），添加如下内容</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">dataDir=/root/zookeeper/data</div><div class="line">dataLogDir=/root/zookeeper/log</div><div class="line">server.1=mini1:2888:3888   #其余节点的主机名，以及通信的端口和检测连接的端口</div><div class="line">server.2=mini2:2888:3888</div><div class="line">server.3=mini3:2888:3888</div></pre></td></tr></table></figure>
</li>
<li><p>在前面定义的dataDir目录下新建muid文件，加入内容1，之后配置的节点依次递增。</p>
</li>
<li><p>启动服务（其余节点需要关闭防火墙）</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">zkServer.sh start  #启动服务</div><div class="line">zkServer.sh status  #查看服务状态（主从节点信息）</div></pre></td></tr></table></figure>
<p>​</p>
</li>
</ol>
<h4 id="Zookeeper的数据管理功能"><a href="#Zookeeper的数据管理功能" class="headerlink" title="Zookeeper的数据管理功能"></a>Zookeeper的数据管理功能</h4><ul>
<li><p>在zookeeper中默认通过树的结构保存用户的元数据</p>
<p>​</p>
<p><img src="http://img.blog.csdn.net/20170805144356427?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemhhb3NodWFpd2pt/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>每一个节点都可以存放数据，类似与文件系统的树形存储目录。</p>
</li>
<li><p>通过命令行连接到zookeeper服务器。</p>
<p>通过解压目录的<code>bin/zkCli.sh</code>可以直接启动命令行的客户端。</p>
</li>
<li><p>在zookeeper中每个节点的数据可以分为两类：</p>
<blockquote>
<ol>
<li>瞬时节点（<strong>ephemeral</strong>）（当连接进程与zookeeper断开连接的一定时间后（心跳时间）就会删除节点）</li>
<li>持久节点（<strong>persistent</strong>）（即时连接进程与zookeeper断开也不会删除该节点）</li>
</ol>
</blockquote>
<p>而且每种节点又分为两种，有序节点与无序节点（<strong>有序节点在创建时会默认在其后添加一个递增的序号</strong>）。所以总共在zookeeper中包括了四种节点。</p>
<blockquote>
<ul>
<li>PERSISTENT</li>
<li>PERSISTENT_SEQUENTIAL（持久序列/test0000000019 ）</li>
<li>EPHEMERAL</li>
<li>EPHEMERAL_SEQUENTIAL</li>
</ul>
</blockquote>
</li>
</ul>
<h4 id="通过客户端对元数据进行管理"><a href="#通过客户端对元数据进行管理" class="headerlink" title="通过客户端对元数据进行管理"></a>通过客户端对元数据进行管理</h4><ul>
<li>通过<code>bin/zkCli.sh</code>我们通过客户端连接到zookeeper，我们可以在命令行对节点进行增删改查操作。</li>
</ul>
<table>
<thead>
<tr>
<th>功能</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>create</td>
<td>在本地目录树中创建一个节点</td>
</tr>
<tr>
<td>delete</td>
<td>删除一个节点</td>
</tr>
<tr>
<td>exists</td>
<td>测试本地是否存在目标节点</td>
</tr>
<tr>
<td>get/set  data</td>
<td>从目标节点上读取 / 写数据</td>
</tr>
<tr>
<td>get/set  ACL</td>
<td>获取 / 设置目标节点访问控制列表信息</td>
</tr>
<tr>
<td>get  children</td>
<td>检索一个子节点上的列表</td>
</tr>
<tr>
<td>sync</td>
<td>等待要被传送的数据</td>
</tr>
</tbody>
</table>
<ul>
<li><p>通过<code>help</code>命令我们可以对查看命令及其使用方法。</p>
<p><img src="http://img.blog.csdn.net/20170806164650973?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemhhb3NodWFpd2pt/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>值得注意的是在<code>ls</code>与<code>get</code>命令后面我们可以对某个数据增加监控，当某个数据发生变化的时候连接进程后收到信号。只能监听一次，完成后后面的事件不会再触发监听。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">get /test/test1 true  #对/test/test1增加监听，当其数据发生变化的时候会收到信息</div><div class="line"><span class="meta">#</span> WatchedEvent state:SyncConnected type:NodeDataChanged path:/test/test1</div><div class="line">ls /test true  #对/test增加监听，子目录下内容发生变化的时候会收到信息。</div><div class="line"><span class="meta">#</span> WatchedEvent state:SyncConnected type:NodeDeleted path:/test/test1</div></pre></td></tr></table></figure>
<p>​</p>
</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/01/python/用python撸出一个静态web服务器/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="forever_zs">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/head.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="帅到没朋友">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/01/python/用python撸出一个静态web服务器/" itemprop="url">python构建简单的静态web服务器</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-01T20:10:33+08:00">
                2017-08-01
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/python进阶/" itemprop="url" rel="index">
                    <span itemprop="name">python进阶</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="python搭建简单的静态web服务器"><a href="#python搭建简单的静态web服务器" class="headerlink" title="python搭建简单的静态web服务器"></a>python搭建简单的静态web服务器</h2><p>[TOC]</p>
<h4 id="储备知识"><a href="#储备知识" class="headerlink" title="储备知识"></a>储备知识</h4><ul>
<li>一丢丢的python（io和多线程的知识）</li>
<li>一丢丢的http协议</li>
<li>一丢丢的tcp/ip协议（当然不了解也没关系）</li>
<li>一丢丢的正则表达式知识</li>
</ul>
<h4 id="web服务器基本原理"><a href="#web服务器基本原理" class="headerlink" title="web服务器基本原理"></a>web服务器基本原理</h4><ul>
<li><p>当在浏览器的地址栏输入一个ip与端口之后，浏览器就会通过tcp/ip协议与相应的主机端口进程建立联系。经历过三次握手之后就会将http请求发送到相应的服务器进程去，之前我们了解的http协议在服务进程收到的其实就是一串有特殊格式的字符串。</p>
<p>当我们浏览器输入<a href="localhost:9876" target="_blank" rel="external">localhost:9876</a> 后服务进程实际收到的如下：</p>
<p><img src="http://img.blog.csdn.net/20170801212433632?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemhhb3NodWFpd2pt/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
</li>
</ul>
<h4 id="大致流程"><a href="#大致流程" class="headerlink" title="大致流程"></a>大致流程</h4><ol>
<li><p>在服务端建立tcp服务进程，为了保证服务端可以同时处理多个请求，我们需要在每接受一个请求后为其单独使用一个线程（或者进程）为其进行服务。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">server = socket(AF_INET, SOCK_STREAM)</div><div class="line">server.setsockopt(SOL_SOCKET, SO_REUSEADDR, <span class="number">1</span>)</div><div class="line">address = (<span class="string">''</span>, <span class="number">9876</span>)</div><div class="line">server.bind(address)</div><div class="line">server.listen(<span class="number">10</span>)</div><div class="line"><span class="keyword">try</span>:</div><div class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">        print(<span class="string">"-------等待接受服务----------"</span>)</div><div class="line">        client, client_address = server.accept()</div><div class="line">        print(<span class="string">"-------接受服务成功----------"</span>)</div><div class="line">        <span class="comment"># 如果使用进程服务，可以在在后面把client关闭。</span></div><div class="line">        p = Thread(target=deal_socket, args=(client,))</div><div class="line">        p.start()</div><div class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</div><div class="line">       print(e)</div><div class="line"><span class="keyword">finally</span>:</div><div class="line">       server.close()</div><div class="line">       print(<span class="string">"-------服务结束----------"</span>)</div></pre></td></tr></table></figure>
<p>这里的deal_socket函数就是我们为一个请求服务的函数，在一个单独的线程中运行。</p>
</li>
<li><p>在处理url请求的函数中，我们需要读取出客户端的http请求。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">deal_socket</span><span class="params">(client)</span>:</span></div><div class="line">    print(<span class="string">"-------开启新的线程----------"</span>)</div><div class="line">    <span class="keyword">try</span>:</div><div class="line">        data = client.recv(<span class="number">1024</span>)</div><div class="line">        <span class="keyword">if</span> len(data) &gt; <span class="number">0</span>:</div><div class="line">            fileName = get_request_name_from_http(data.decode(<span class="string">"utf-8"</span>))</div><div class="line">            writeHtml(client, fileName)</div><div class="line"></div><div class="line">    <span class="keyword">finally</span>:</div><div class="line">        client.close()</div><div class="line">        print(<span class="string">"-------关闭新的线程----------"</span>)</div></pre></td></tr></table></figure>
<ul>
<li>在这里的data就是我们读取到的http服务请求，当其长度等于0时代表客户端已经关闭了tcp连接。</li>
<li>这里的get_request_name_from_http()需要我们解析出请求的静态资源</li>
<li>这里的writeHtml()将静态文本写回到客户端。</li>
</ul>
</li>
<li><p>在<strong>get_request_name_from_http</strong>函数中我们需要从原始的url请求中解析出http请求中我们需要的请求资源部分，这里我们可以通过正则表达式完成简单的完成解析。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_request_name_from_http</span><span class="params">(http)</span>:</span></div><div class="line">    <span class="comment"># 注意这里通过非贪婪模式匹配</span></div><div class="line">    r = re.search(<span class="string">r"GET /(.+?) "</span>, http)</div><div class="line">    fileName = <span class="string">""</span></div><div class="line">    <span class="keyword">if</span> r != <span class="keyword">None</span>:</div><div class="line">        fileName = r.group(<span class="number">1</span>)</div><div class="line">    <span class="keyword">return</span> fileName</div></pre></td></tr></table></figure>
<ul>
<li><p>请求的http大概格式是这样（当我们访问<a href="http://localhost:9876/html/index.html时）" target="_blank" rel="external">http://localhost:9876/html/index.html时）</a></p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">GET</span> <span class="string">/html/index.html</span> HTTP/1.1</div><div class="line"><span class="attribute">Host</span>: localhost:9876</div><div class="line"><span class="attribute">Connection</span>: keep-alive</div><div class="line"><span class="attribute">Cache-Control</span>: max-age=0</div><div class="line"><span class="attribute">Upgrade-Insecure-Requests</span>: 1</div><div class="line"><span class="attribute">User-Agent</span>: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/59.0.3071.109 Safari/537.36</div></pre></td></tr></table></figure>
<p>第一行就是我们请求的静态资源，我们将其通过非贪婪模式的正则表达式扣出来。</p>
</li>
</ul>
</li>
<li><p>在解析到请求的静态地址后就是简单的读取请求的文件，然后已http协议的格式返回回去就行了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">writeHtml</span><span class="params">(client, fileName)</span>:</span></div><div class="line">    rspHead = <span class="keyword">None</span></div><div class="line">    rspBody = <span class="keyword">None</span></div><div class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(fileName):</div><div class="line">        rspHead = <span class="string">"HTTP/1.1 404 error\r\nServer: foreverServer\r\n\r\n"</span></div><div class="line">        rspBody = <span class="string">"file not found"</span></div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        rspHead = <span class="string">"HTTP/1.1 200 OK\r\nServer: foreverServer\r\n\r\n"</span></div><div class="line">        html = open(fileName, <span class="string">'r'</span>, encoding=<span class="string">'UTF-8'</span>)</div><div class="line">        rspBody = html.read()</div><div class="line">    client.send((rspHead + rspBody).encode(<span class="string">"utf-8"</span>))</div></pre></td></tr></table></figure>
<ul>
<li><p>当请求的静态文件不存在时，将返回给客户端文件不存在。</p>
</li>
<li><p>上面的相应格式是根据http相应报文的格式而定的，否则浏览器会不识别：</p>
<p>​</p>
<p><img src="http://img.blog.csdn.net/20170801215423998?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemhhb3NodWFpd2pt/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>在Windows中\r\n分别代表回车和换行，而现在在unix系统中\n就代表了回车换行。</p>
<p>​</p>
<h4 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h4></li>
</ul>
</li>
</ol>
<ul>
<li><p>下面是完整的服务代码，不到60行就可以完成一个简单的静态web服务器，这就是python的魅力：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</div><div class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</div><div class="line"><span class="keyword">import</span> os</div><div class="line"><span class="keyword">import</span> re</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_request_name_from_http</span><span class="params">(http)</span>:</span></div><div class="line">    r = re.search(<span class="string">r"GET /(.+?) "</span>, http)</div><div class="line">    fileName = <span class="string">""</span></div><div class="line">    <span class="keyword">if</span> r != <span class="keyword">None</span>:</div><div class="line">        fileName = r.group(<span class="number">1</span>)</div><div class="line">    <span class="keyword">return</span> fileName</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">writeHtml</span><span class="params">(client, fileName)</span>:</span></div><div class="line">    rspHead = <span class="keyword">None</span></div><div class="line">    rspBody = <span class="keyword">None</span></div><div class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(fileName):</div><div class="line">        rspHead = <span class="string">"HTTP/1.1 404 error\r\nServer: foreverServer\r\n\r\n"</span></div><div class="line">        rspBody = <span class="string">"file not found"</span></div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        rspHead = <span class="string">"HTTP/1.1 200 OK\r\nServer: foreverServer\r\n\r\n"</span></div><div class="line">        html = open(fileName, <span class="string">'r'</span>, encoding=<span class="string">'UTF-8'</span>)</div><div class="line">        rspBody = html.read()</div><div class="line">    client.send((rspHead + rspBody).encode(<span class="string">"utf-8"</span>))</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">deal_socket</span><span class="params">(client)</span>:</span></div><div class="line">    print(<span class="string">"-------开启新的线程----------"</span>)</div><div class="line">    <span class="keyword">try</span>:</div><div class="line">        data = client.recv(<span class="number">1024</span>)</div><div class="line">        <span class="keyword">if</span> len(data) &gt; <span class="number">0</span>:</div><div class="line">            fileName = get_request_name_from_http(data.decode(<span class="string">"utf-8"</span>))</div><div class="line">            writeHtml(client, fileName)</div><div class="line"></div><div class="line">    <span class="keyword">finally</span>:</div><div class="line">        client.close()</div><div class="line">        print(<span class="string">"-------关闭新的线程----------"</span>)</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></div><div class="line">    server = socket(AF_INET, SOCK_STREAM)</div><div class="line">    server.setsockopt(SOL_SOCKET, SO_REUSEADDR, <span class="number">1</span>)</div><div class="line">    address = (<span class="string">''</span>, <span class="number">9876</span>)</div><div class="line">    server.bind(address)</div><div class="line">    server.listen(<span class="number">10</span>)</div><div class="line">    <span class="keyword">try</span>:</div><div class="line">        <span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">            print(<span class="string">"-------等待接受服务----------"</span>)</div><div class="line">            client, client_address = server.accept()</div><div class="line">            print(<span class="string">"-------接受服务成功----------"</span>)</div><div class="line">            <span class="comment"># 就这里和多线程不同，并且千万不能把client关掉</span></div><div class="line">            p = Thread(target=deal_socket, args=(client,))</div><div class="line">            p.start()</div><div class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</div><div class="line">        print(e)</div><div class="line">    <span class="keyword">finally</span>:</div><div class="line">        server.close()</div><div class="line">        print(<span class="string">"-------服务结束----------"</span>)</div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</div><div class="line">    main()</div></pre></td></tr></table></figure>
</li>
<li><p>到此就用python构建了史上最挫的静态wen服务器了，直接在浏览其输入静态html请求就可以显示网页了：</p>
<p><img src="http://img.blog.csdn.net/20170801220650625?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemhhb3NodWFpd2pt/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>虽然很挫，不过web服务器的基本原理就是如此，牛逼的服务器也只是在这之上做了很多完善，下一篇我们将采用python提供的WSGI标准完成一个动态的web框架。</p>
</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/07/20/JVM/Jvm运行机制/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="forever_zs">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/head.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="帅到没朋友">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/07/20/JVM/Jvm运行机制/" itemprop="url">java运行时内存管理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-07-20T20:10:33+08:00">
                2017-07-20
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/jvm/" itemprop="url" rel="index">
                    <span itemprop="name">jvm</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="java运行时内存管理"><a href="#java运行时内存管理" class="headerlink" title="java运行时内存管理"></a>java运行时内存管理</h1><ul>
<li><p>Java运行时的数据区<br><img src="http://img.blog.csdn.net/20170418194309194?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemhhb3NodWFpd2pt/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
</li>
<li><p>各个部分的数据简介</p>
<ol>
<li><p>程序计数器（<strong>线程私有</strong>）</p>
<p>是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。</p>
</li>
<li><p>Java虚拟机栈（线程私有，生命周期与线程相同）</p>
<p>由一系列<code>栈帧</code>构成，用于存储<strong><em>局部变量表</em></strong>、操作数栈、动态链接、方法出口等信息。每一次的方法调用创建一个帧，并压栈。</p>
</li>
<li><p>本地方法栈</p>
<p>本地方法栈（Native Method Stack）与虚拟机栈所发挥的作用是非常相似的。虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则为虚拟机使用到的Native方法服务。</p>
</li>
<li><p>Java堆（与程序开发最密切）</p>
<p>Java堆（Java Heap）是Java虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例</p>
</li>
<li><p>方法区（保存装载的类信息。）</p>
<p>方法区（Method Area）与Java堆一样，是各个<strong>线程共享</strong>的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</p>
</li>
</ol>
</li>
<li><p>Java对象的创建过程</p>
<p>虚拟机遇到一条new指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，那必须先执行相应的类加载过程，接下来虚拟机将为新生对象分配内存。</p>
<p>举个栗子：下图是对下面执行代码的图解</p>
<p><img src="http://img.blog.csdn.net/20170509170125021?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemhhb3NodWFpd2pt/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppMain</span> </span>&#123;</div><div class="line">	<span class="comment">// 运行时, jvm 把appmain的信息都放入方法区 </span></div><div class="line">	<span class="function"><span class="keyword">public</span>   <span class="keyword">static</span>   <span class="keyword">void</span>  <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">	<span class="comment">//main 方法本身放入方法区。 </span></div><div class="line">	Sample test1 = <span class="keyword">new</span>  Sample( <span class="string">" 测试1 "</span> );  </div><div class="line">	<span class="comment">//test1是引用，所以放到栈区里， Sample是自定义对象应该放到堆里面 </span></div><div class="line">	test1.printName(); </div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>​</p>
</li>
<li><p>Jvm的内存模型（重点）</p>
<p>–每一个线程有一个工作内存和主存独立</p>
<p>–工作内存存放主存中变量的值的拷贝</p>
<p><img src="http://img.blog.csdn.net/20170509205556297?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemhhb3NodWFpd2pt/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<blockquote>
<ul>
<li>当数据从主内存复制到工作存储时，必须出现两个动作：第一，由主内存执行的读（read）操作；第二，由工作内存执行的相应的load操作；</li>
<li>当数据从工作内存拷贝到主内存时，也出现两个操作：第一个，由工作内存执行的存储（store）操作；第二，由主内存执行的相应的写（write）操作。</li>
</ul>
</blockquote>
<p>每一个操作都具有原子性，不会中断。由于工作内存的存在，所以在另一个线程中的变量值被修改其他线程使用该变量时并不会得到最新的变量值，<strong><em>可以可以通过Volatile关键字使得在其他线程中立即可见。</em></strong></p>
</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/07/18/数据库/mysql/MySql的索引/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="forever_zs">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/head.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="帅到没朋友">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/07/18/数据库/mysql/MySql的索引/" itemprop="url">MySql索引</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-07-18T00:00:00+08:00">
                2017-07-18
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MySql/" itemprop="url" rel="index">
                    <span itemprop="name">MySql</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="MySql索引"><a href="#MySql索引" class="headerlink" title="MySql索引"></a>MySql索引</h2><p>[TOC]</p>
<h4 id="神马是MySql索引"><a href="#神马是MySql索引" class="headerlink" title="神马是MySql索引"></a>神马是MySql索引</h4><p>​    数据库索引是一种数据结构，目的是提高表的操作速度。要创建的索引，应当认为哪列将用于使SQL查询，创<strong>建对这些列的一个或多个索引。</strong>实际上，索引也是表，其中保存主键或索引字段的指针并指向每个记录到实际的表的类型。</p>
<p>​    索引一方面可以提高数据的检索速度，不过另一方面过多的索引会降低表的gen更新速度，（因为在更新表的同时也会更新索引。）</p>
<h4 id="索引的基本用法"><a href="#索引的基本用法" class="headerlink" title="索引的基本用法"></a>索引的基本用法</h4><ol>
<li><p>创建与修改普通索引</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> indexName <span class="keyword">ON</span> mytable(username(<span class="keyword">length</span>)); </div><div class="line">//创建表的时候直接指定</div><div class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> mytable(  </div><div class="line"><span class="keyword">ID</span> <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,   </div><div class="line">username <span class="built_in">VARCHAR</span>(<span class="number">16</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,  </div><div class="line"><span class="keyword">INDEX</span> [indexName] (username(<span class="keyword">length</span>))  </div><div class="line">);  </div><div class="line">//修改索引</div><div class="line"><span class="keyword">ALTER</span> mytable <span class="keyword">ADD</span> <span class="keyword">INDEX</span> [indexName] <span class="keyword">ON</span> (username(<span class="keyword">length</span>)) </div><div class="line">//删除索引</div><div class="line"><span class="keyword">DROP</span> <span class="keyword">INDEX</span> [indexName] <span class="keyword">ON</span> mytable;</div></pre></td></tr></table></figure>
</li>
<li><p>创建与修改复合索引</p>
<p>复合索引是在多个字段上创建的索引。<strong>复合索引遵守“最左前缀”原则，即在查询条件中使用了复合索引的第一个字段，索引才会被使用。</strong>因此，在复合索引中索引列的顺序至关重要。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">create</span> <span class="keyword">index</span> index_name <span class="keyword">on</span> tbl_name(index_col_name,...);</div><div class="line">//修改索引</div><div class="line"><span class="keyword">alter</span> <span class="keyword">table</span> tbl_name <span class="keyword">add</span> <span class="keyword">index</span> index_name <span class="keyword">on</span> (index_col_name,...);</div></pre></td></tr></table></figure>
</li>
<li><p>创建与修改唯一索引</p>
<p>唯一索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">CREATE</span> <span class="keyword">UNIQUE</span> <span class="keyword">INDEX</span> indexName <span class="keyword">ON</span> mytable(username(<span class="keyword">length</span>)) </div><div class="line">//创建表的时候直接指定</div><div class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> mytable(  </div><div class="line"><span class="keyword">ID</span> <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,   </div><div class="line">username <span class="built_in">VARCHAR</span>(<span class="number">16</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,  </div><div class="line"><span class="keyword">UNIQUE</span> [indexName] (username(<span class="keyword">length</span>))  </div><div class="line">);  </div><div class="line">//修改索引</div><div class="line"><span class="keyword">ALTER</span> <span class="keyword">table</span> mytable <span class="keyword">ADD</span> <span class="keyword">UNIQUE</span> [indexName] (username(<span class="keyword">length</span>))</div></pre></td></tr></table></figure>
</li>
<li><p>创建与修改主键索引</p>
<p>主键索引值必须是唯一的，且不能为NULL。（默认创建主键都会为该列创建索引）</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tbl_name <span class="keyword">ADD</span> PRIMARY <span class="keyword">KEY</span> (column_list)</div><div class="line">//删除索引</div><div class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> testalter_tbl <span class="keyword">DROP</span> PRIMARY <span class="keyword">KEY</span>;</div></pre></td></tr></table></figure>
</li>
<li><p>创建与修改全文索引</p>
<p>它能够利用「分词技术「等多种算法智能分析出文本文字中关键字词的频率及重要性，然后按照一定的算法规则智能地筛选出我们想要的搜索结果。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> article (</div><div class="line">    <span class="keyword">id</span> <span class="built_in">INT</span> <span class="keyword">UNSIGNED</span> AUTO_INCREMENT <span class="keyword">NOT</span> <span class="literal">NULL</span> PRIMARY <span class="keyword">KEY</span>,</div><div class="line">    title <span class="built_in">VARCHAR</span>(<span class="number">200</span>),</div><div class="line">    <span class="keyword">content</span> <span class="built_in">TEXT</span>,</div><div class="line">    FULLTEXT (title, <span class="keyword">content</span>) <span class="comment">--在title和content列上创建全文索引</span></div><div class="line">);</div><div class="line">//修改索引</div><div class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> article <span class="keyword">ADD</span> FULLTEXT <span class="keyword">INDEX</span> fulltext_article (title, <span class="keyword">content</span>)</div></pre></td></tr></table></figure>
<p>如何使用全文索引</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">//在article表的title和content列中全文检索指定的查询字符串</div><div class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> article <span class="keyword">WHERE</span> <span class="keyword">MATCH</span>(title, <span class="keyword">content</span>) AGAINST(<span class="string">'查询字符串'</span>)</div></pre></td></tr></table></figure>
<p>MySQL自带的全文索引只能对英文进行全文检索，目前无法对中文进行全文检索。如果需要对包含中文在内的文本数据进行全文检索，我们需要采用Sphinx(斯芬克斯)/Coreseek技术来处理中文。</p>
</li>
</ol>
<h4 id="使用索引的注意事项"><a href="#使用索引的注意事项" class="headerlink" title="使用索引的注意事项"></a>使用索引的注意事项</h4><ul>
<li><p>不要在列上进行运算或者函数</p>
<p>在索引列上进行运算或使用函数会导致索引失效</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> <span class="keyword">YEAR</span>(birthday)&lt;<span class="number">1990</span> <span class="keyword">and</span> code=<span class="string">""</span>&gt;</div></pre></td></tr></table></figure>
</li>
<li><p>不要为多个列创建索引</p>
<p>为多个列创建独立的索引，大部分并不能提高MySQL的查询性能。因为执行查询时，MySQL只能使用一个索引，会从多个索引中选择一个限制最为严格的索引。</p>
</li>
<li><p>索引不会包含有NULL值的列</p>
<p>只要列中包含有NULL值都将不会被包含在索引中，复合索引中只要有一列含有NULL值，那么这一列对于此复合索引就是无效的。所以我们在数据库设计时不要让字段的默认值为NULL。</p>
</li>
<li><p>范围查询对多列查询的影响</p>
<p>如果查询中的某个列有范围查询，则其右边所有列都无法使用索引优化查找。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">where age&gt;10 and age&lt;90 and name="lianggzone" &gt;</div></pre></td></tr></table></figure>
<p>这是因为age是范围查询，导致多列索引t_index(age,name)，无法用到name索引。</p>
<p>​</p>
</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/head.jpg"
               alt="forever_zs" />
          <p class="site-author-name" itemprop="name">forever_zs</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">25</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              
                <span class="site-state-item-count">14</span>
                <span class="site-state-item-name">分类</span>
              
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">38</span>
                <span class="site-state-item-name">标签</span>
              
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/forever-zs" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://twitter.com/your-user-name" target="_blank" title="Twitter">
                  
                    <i class="fa fa-fw fa-twitter"></i>
                  
                  Twitter
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/forever_zs_forever" target="_blank" title="微博">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  微博
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://douban.com/people/your-user-name" target="_blank" title="豆瓣">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  豆瓣
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://www.zhihu.com/people/your-user-name" target="_blank" title="知乎">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  知乎
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">forever_zs</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>

  
  <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.1"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  





  





  






  





  

  

  

  

  

</body>
</html>
